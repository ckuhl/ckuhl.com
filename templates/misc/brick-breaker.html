<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width; initial-scale = 1.0; maximum-scale=1.0; user-scalable=no"/>
    <title>Brick Breaker</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/brick-breaker.css') }}">
</head>

<body>
    <canvas width="100%" height="100%" id="brick-breaker"></canvas>
<script src="{{ url_for('static', filename='js/jquery-3.1.1.js') }}" data-no-instant></script>
<script src="{{ url_for('static', filename='js/brick-breaker.js') }}" data-no-instant></script>
<script>
    // initialize canvas object
    var canvas = document.getElementById("brick-breaker");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var context = canvas.getContext("2d");


    // Listen for user controls
    var mousePosX = window.innerWidth / 2;
    document.addEventListener("mousemove", mouseMoveHandler, false);
    document.addEventListener("touchmove", mouseMoveHandler, false);
    function mouseMoveHandler(e) {
        mousePosX = e.clientX;
    }

    var bricks = [];
    for (var x = 0; x < 6; x++) {
        bricks[x] = [];
        for (var y = 0; y < 3; y++) {
            var wf = canvas.width / 8;
            var pdd = 4;
            bricks[x][y] = new Brick(pdd + (pdd + wf) * x,
                    pdd + (pdd + wf) * y, wf, wf);
            console.log(wf + wf * x, wf + wf * y, wf, wf);
        }
    }
    function draw_bricks() {
        for (var i = 0; i < 6; i++) {
            for (var j = 0; j < 3; j++) {
                b = bricks[i][j];
                if ( b.is_alive ) {
                    context.fillStyle = "#AD2323";
                    context.fillRect(b.x, b.y, b.w, b.h);
                }
            }
        }
    }
    function bricks_collision() {
        for (var i = 0; i < 6; i++) {
            for (var j = 0; j < 3; j++) {
                b = bricks[i][j];
                if (b.is_alive
                        && (Ball.x + Ball.r > b.x)
                        && (Ball.x - Ball.r < (b.x + b.w))
                        && (Ball.y + Ball.r > b.y)
                        && (Ball.y - Ball.r < (b.y + b.h))) {
                    b.kill();
                    InfoBar.updateScore(1, 1);
                    Ball.dy *= -1;
                }
            }
        }
    }


    var InfoBar = {
        score: 0,
        lives: 3,
        updateScore: function(brick, level) {
            this.score += (brick * level);
        },
        loseLife: function(){
            this.lives -= 1;
        },
        livesString: function(){
            ls = "";
            for (var i = 0; i < this.lives; i ++ ){
                ls += "❤";
            }
            return ls;
        },
        draw: function(){
            context.font = "x-large Arial";
            context.fillStyle = "#000000";
            context.fillRect(0, 0, canvas.width, canvas.height / 16);
            context.fillStyle = "#FFFFFF";
            context.fillText(this.livesString(), canvas.width / 32, canvas.height / 64 * 3);
            context.fillText(this.score.toString(), (canvas.width / 8) * 7, canvas.height / 64 * 3);
        },
    };


    // ball that breaks bricks
    var Ball = {
        x: canvas.width / 2,
        y: canvas.height / 8 * 5,
        r: 10,
        dx: 2,
        dy: 2,
        draw: function (){
            context.beginPath();
            context.arc(Ball.x, Ball.y, Ball.r, 0, Math.PI*2);
            context.fillStyle = "#0095DD";
            context.fill();
            context.closePath();
        },
        update: function(){
            Ball.x += Ball.dx;
            Ball.y += Ball.dy;
        },
        reset: function(){
            Ball.x = canvas.width / 2;
            Ball.y = canvas.height / 8 * 5
        }
    };


    // player controlled paddle
    var Paddle = {
        x: mousePosX,
        y: canvas.height - 58,
        w: 60,
        h: 8,
        dx: 3,
        dy: 0,
        draw: function() {
            context.fillStyle = "#FFF000";
            context.fillRect(this.x, this.y, this.w, this.h);
        },
        update: function() {
            Paddle.x = mousePosX - (Paddle.w / 2);
        }
    };


    // the game coordinates all the other objects
    var Game = {
        draw: function(){
            context.clearRect(0, 0,
                    canvas.width,
                    canvas.height);
            Ball.draw();
            Paddle.draw();
            draw_bricks();
            InfoBar.draw();
        },

        update: function(){
            Game.collision_check();
            Ball.update();
            Paddle.update();
        },

        collision_check: function(){
            // Walls
            if ( (Ball.x - Ball.r) < 0 || (Ball.x + Ball.r) > canvas.width) {
                Ball.dx *= -1
            }
            if ( (Ball.y - Ball.r) < 0) {
                Ball.dy *= -1
            }
            if ((Ball.y + Ball.r) > canvas.height){
                InfoBar.loseLife();
                Ball.reset();
            }

            if ( (Ball.x + Ball.r > Paddle.x) && (Ball.x - Ball.r < (Paddle.x + Paddle.w))
            && (Ball.y + Ball.r > Paddle.y) && (Ball.y - Ball.r < (Paddle.y + Paddle.h))) {
                Ball.dy *= -1;
            }

            bricks_collision();
        }
    };

    setInterval(Game.draw, 10);
    setInterval(Game.update, 10);

</script>
</body>
</html>